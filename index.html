<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>S23 Ultra - AI Racer Fix</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #video-preview { 
            position: absolute; top: 10px; right: 10px; width: 140px; height: 100px; 
            border: 2px solid #0f0; border-radius: 8px; transform: scaleX(-1); z-index: 100;
        }
        #stats { position: absolute; top: 10px; left: 10px; color: #0f0; z-index: 100; font-weight: bold; }
    </style>
</head>
<body>

    <div id="stats">SKOR: <span id="score">0</span></div>
    <video id="webcam" autoplay playsinline style="display:none"></video>
    <canvas id="video-preview"></canvas>
    <div id="game-container"></div>

    <script type="module">
        import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

        const video = document.getElementById("webcam");
        const previewCanvas = document.getElementById("video-preview");
        const previewCtx = previewCanvas.getContext("2d");
        const scoreElement = document.getElementById("score");

        let handLandmarker;
        let lastVideoTime = -1;
        let steeringAngle = 0;
        let score = 0;

        const config = {
            type: Phaser.AUTO,
            parent: 'game-container',
            width: window.innerWidth,
            height: window.innerHeight,
            physics: { default: 'arcade' },
            scene: { preload, create, update }
        };

        const game = new Phaser.Game(config);
        let player, roadLines, obstacles;
        let speed = 8;

        function preload() {}

        function create() {
            // Asfalt
            this.add.rectangle(config.width/2, config.height/2, config.width * 0.7, config.height, 0x222222);
            
            // Yol Kenarları (Çimen/Emniyet Şeridi)
            this.add.rectangle(config.width * 0.15, config.height/2, config.width * 0.05, config.height, 0x006600);
            this.add.rectangle(config.width * 0.85, config.height/2, config.width * 0.05, config.height, 0x006600);

            // Yol Çizgileri
            roadLines = this.add.group();
            for(let i=0; i<10; i++) {
                roadLines.add(this.add.rectangle(config.width/2, i * 100, 10, 50, 0xffffff));
            }

            // Oyuncu Arabası (Sabit Y ekseni!)
            player = this.add.rectangle(config.width/2, config.height - 150, 50, 80, 0xff0000);
            this.physics.add.existing(player);

            obstacles = this.physics.add.group();

            // Engel Yaratıcı
            this.time.addEvent({
                delay: 1000,
                callback: () => {
                    let x = Phaser.Math.Between(config.width * 0.2, config.width * 0.8);
                    let obs = this.add.rectangle(x, -50, 40, 40, 0x00ff00);
                    obstacles.add(obs);
                    this.physics.world.enable(obs);
                },
                loop: true
            });

            // Çarpışma Kontrolü
            this.physics.add.overlap(player, obstacles, () => {
                this.scene.restart();
                score = 0;
                speed = 8;
            });
        }

        function update() {
            // Yol Akışı
            roadLines.getChildren().forEach(line => {
                line.y += speed;
                if (line.y > config.height) line.y = -50;
            });

            // Engellerin Akışı
            obstacles.getChildren().forEach(obs => {
                obs.y += speed;
                if (obs.y > config.height) obs.destroy();
            });

            // Direksiyon Kontrolü (Hassas ve Sınırlı)
            let targetX = (config.width / 2) + (steeringAngle * 6);
            player.x = Phaser.Math.Linear(player.x, targetX, 0.2);
            
            // Arabanın yoldan çıkmasını engelle
            player.x = Phaser.Math.Clamp(player.x, config.width * 0.2, config.width * 0.8);
            player.angle = steeringAngle * 0.5;

            score++;
            scoreElement.innerText = Math.floor(score / 10);
            speed += 0.002; // Zamanla hızlan
        }

        // --- AI ---
        async function initAI() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 2
            });
            startKamera();
        }

        function startKamera() {
            navigator.mediaDevices.getUserMedia({ video: true }).then(s => {
                video.srcObject = s;
                video.addEventListener("loadeddata", predict);
            });
        }

        async function predict() {
            previewCanvas.width = video.videoWidth;
            previewCanvas.height = video.videoHeight;
            if (lastVideoTime !== video.currentTime) {
                lastVideoTime = video.currentTime;
                const result = handLandmarker.detectForVideo(video, performance.now());
                previewCtx.drawImage(video, 0, 0, previewCanvas.width, previewCanvas.height);

                if (result.landmarks && result.landmarks.length === 2) {
                    const h1 = result.landmarks[0][0];
                    const h2 = result.landmarks[1][0];
                    let deg = Math.atan2(h2.y - h1.y, h2.x - h1.x) * (180 / Math.PI);
                    if (deg > 90) deg -= 180;
                    if (deg < -90) deg += 180;
                    steeringAngle = -deg * 1.5;
                }
            }
            requestAnimationFrame(predict);
        }

        initAI();
    </script>
</body>
</html>