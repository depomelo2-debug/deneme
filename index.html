<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>S23 Ultra - 2 Player AI Road Fighter</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #game-container { width: 100vw; height: 100vh; }
        #video-preview { 
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%) scaleX(-1); 
            width: 240px; height: 180px; border: 2px solid #0f0; border-radius: 10px; z-index: 100; opacity: 0.8;
        }
        .ui { position: absolute; top: 20px; color: white; z-index: 50; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; font-size: 12px; }
        #p1-ui { left: 20px; border-left: 5px solid #00f; }
        #p2-ui { right: 20px; border-right: 5px solid #f00; }
    </style>
</head>
<body>

    <div id="p1-ui" class="ui">P1 (SOL): <span id="p1-score">0</span></div>
    <div id="p2-ui" class="ui">P2 (SAĞ): <span id="p2-score">0</span></div>
    
    <video id="webcam" autoplay playsinline style="display:none"></video>
    <canvas id="video-preview"></canvas>
    <div id="game-container"></div>

    <script type="module">
        import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

        const video = document.getElementById("webcam");
        const previewCanvas = document.getElementById("video-preview");
        const previewCtx = previewCanvas.getContext("2d");

        let handLandmarker;
        let lastVideoTime = -1;
        
        // Direksiyon açıları
        let p1Angle = 0;
        let p2Angle = 0;

        const config = {
            type: Phaser.AUTO,
            parent: 'game-container',
            width: window.innerWidth,
            height: window.innerHeight,
            physics: { default: 'arcade' },
            scene: { preload, create, update }
        };

        const game = new Phaser.Game(config);
        let p1Car, p2Car, roadLines, obstacles;
        let speed = 7;
        let p1Active = true, p2Active = true;

        function preload() {}

        function create() {
            // Orta çizgi (Ekranı bölen)
            this.add.rectangle(config.width/2, config.height/2, 4, config.height, 0x555555);

            // Yol çizgileri grubu
            roadLines = this.add.group();
            for(let i=0; i<15; i++) {
                roadLines.add(this.add.rectangle(config.width * 0.25, i * 80, 8, 40, 0xffffff));
                roadLines.add(this.add.rectangle(config.width * 0.75, i * 80, 8, 40, 0xffffff));
            }

            // P1 Araba (Mavi)
            p1Car = this.physics.add.rectangle(config.width * 0.25, config.height - 100, 50, 80, 0x0000ff);
            // P2 Araba (Kırmızı)
            p2Car = this.physics.add.rectangle(config.width * 0.75, config.height - 100, 50, 80, 0xff0000);

            obstacles = this.physics.add.group();

            // Çarpışmalar
            this.physics.add.overlap(p1Car, obstacles, (car, obs) => { p1Active = false; car.setAlpha(0.3); });
            this.physics.add.overlap(p2Car, obstacles, (car, obs) => { p2Active = false; car.setAlpha(0.3); });

            // Periyodik Engel
            this.time.addEvent({ delay: 800, callback: addObstacle, callbackScope: this, loop: true });
        }

        function addObstacle() {
            // Sol tarafa engel
            if(p1Active) {
                let obs1 = this.add.rectangle(Phaser.Math.Between(50, config.width/2 - 50), -50, 40, 40, 0xffff00);
                obstacles.add(obs1);
                this.physics.world.enable(obs1);
            }
            // Sağ tarafa engel
            if(p2Active) {
                let obs2 = this.add.rectangle(Phaser.Math.Between(config.width/2 + 50, config.width - 50), -50, 40, 40, 0xffa500);
                obstacles.add(obs2);
                this.physics.world.enable(obs2);
            }
        }

        function update() {
            // Yol akışı
            roadLines.getChildren().forEach(line => {
                line.y += speed;
                if(line.y > config.height) line.y = -40;
            });

            // Engelleri aşağı kaydır
            obstacles.getChildren().forEach(obs => {
                obs.y += speed;
                if(obs.y > config.height) obs.destroy();
            });

            // P1 Hareket (Ekranın sol yarısında sınırla)
            if(p1Active) {
                let p1TargetX = (config.width * 0.25) + (p1Angle * 4);
                p1Car.x = Phaser.Math.Clamp(p1TargetX, 30, config.width/2 - 30);
                p1Car.angle = p1Angle * 0.5;
            }

            // P2 Hareket (Ekranın sağ yarısında sınırla)
            if(p2Active) {
                let p2TargetX = (config.width * 0.75) + (p2Angle * 4);
                p2Car.x = Phaser.Math.Clamp(p2TargetX, config.width/2 + 30, config.width - 30);
                p2Car.angle = p2Angle * 0.5;
            }

            speed += 0.001; // Giderek hızlan
        }

        // --- AI MANTIĞI ---
        async function initAI() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 4 // 2 kişi = 4 el
            });
            startKamera();
        }

        function startKamera() {
            navigator.mediaDevices.getUserMedia({ video: true }).then(s => {
                video.srcObject = s;
                video.addEventListener("loadeddata", predict);
            });
        }

        async function predict() {
            previewCanvas.width = video.videoWidth;
            previewCanvas.height = video.videoHeight;
            if (lastVideoTime !== video.currentTime) {
                lastVideoTime = video.currentTime;
                const result = handLandmarker.detectForVideo(video, performance.now());
                previewCtx.clearRect(0,0,240,180);
                previewCtx.drawImage(video, 0, 0, previewCanvas.width, previewCanvas.height);

                if (result.landmarks && result.landmarks.length >= 2) {
                    // Elleri ekranın solundaki ve sağındakiler diye ayır
                    const hands = result.landmarks.sort((a,b) => a[0].x - b[0].x);
                    
                    // En soldaki iki el P1
                    if(hands.length >= 2) {
                        p1Angle = calculateAngle(hands[0][0], hands[1][0]);
                    }
                    // En sağdaki iki el P2 (Eğer varsa)
                    if(hands.length >= 4) {
                        p2Angle = calculateAngle(hands[2][0], hands[3][0]);
                    }
                }
            }
            requestAnimationFrame(predict);
        }

        function calculateAngle(pt1, pt2) {
            let deg = Math.atan2(pt2.y - pt1.y, pt2.x - pt1.x) * (180 / Math.PI);
            if (deg > 90) deg -= 180;
            if (deg < -90) deg += 180;
            return Phaser.Math.Clamp(-deg * 2, -45, 45);
        }

        initAI();
    </script>
</body>
</html>