<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Road Fighter NES - Ultra Edition</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/vision_bundle.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        #webcam { display: none; }
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
            background: #000; z-index: 500; display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: #fff;
        }
        .menu-btn {
            width: 320px; padding: 18px; margin: 12px; border: 4px double #555;
            background: #111; color: #888; font-size: 18px; font-weight: bold;
            transition: all 0.2s; outline: none;
        }
        /* Kumanda seçimi için parlayan efekt */
        .menu-btn.active {
            border-color: #ffff00; color: #fff; background: #222;
            transform: scale(1.1); box-shadow: 0 0 20px #f00;
        }
        #ui-side { position: absolute; top: 20px; left: 140px; color: #fff; z-index: 200; display: none; text-shadow: 2px 2px #000; }
        #kmh-box { font-size: 32px; font-weight: bold; color: #00ff00; }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1 style="color:#ffff00; text-shadow: 3px 3px #f00; font-size: 40px; margin-bottom:40px;">ROAD FIGHTER</h1>
        <div class="menu-btn active" data-mode="camera">1. AI CAMERA</div>
        <div class="menu-btn" data-mode="gyro">2. PHONE TILT</div>
        <div class="menu-btn" data-mode="keyboard">3. KEYBOARD / REMOTE</div>
        <p style="color: #666; font-size: 14px; margin-top: 20px;">KUMANDA VEYA MOUSE İLE SEÇİN</p>
    </div>

    <div id="ui-side">
        <div style="color: #ffff00; font-size: 16px;">1P SCORE</div>
        <div style="font-size: 28px;" id="score">000000</div>
        <br>
        <div style="color: #ffff00; font-size: 16px;">VELOCITY</div>
        <div id="kmh-box"><span id="kmh">0</span> km/h</div>
    </div>

    <video id="webcam" autoplay playsinline></video>
    <div id="game-container"></div>

    <script type="module">
        import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

        // --- MENÜ KONTROLÜ (MI BOX FIX) ---
        let currentIndex = 0;
        const menuButtons = document.querySelectorAll('.menu-btn');
        const modes = ['camera', 'gyro', 'keyboard'];

        function updateMenu() {
            menuButtons.forEach((btn, idx) => {
                if(idx === currentIndex) btn.classList.add('active');
                else btn.classList.remove('active');
            });
        }

        window.addEventListener('keydown', (e) => {
            if (window.controlMode === null) {
                if (e.key === 'ArrowDown') { currentIndex = (currentIndex + 1) % modes.length; updateMenu(); }
                else if (e.key === 'ArrowUp') { currentIndex = (currentIndex - 1 + modes.length) % modes.length; updateMenu(); }
                else if (e.key === 'Enter' || e.keyCode === 13 || e.keyCode === 66) { startGame(modes[currentIndex]); }
            } else if (window.controlMode === 'keyboard') {
                if (e.key === 'ArrowLeft') steeringInput -= 0.08;
                if (e.key === 'ArrowRight') steeringInput += 0.08;
                if (e.key === 'ArrowUp' || e.key === 'Enter') throttleInput = 0.3;
            }
        });

        window.addEventListener('keyup', (e) => {
            if (window.controlMode === 'keyboard') {
                if (e.key === 'ArrowUp' || e.key === 'Enter') throttleInput = 0.8;
            }
        });

        // --- OYUN AYARLARI ---
        window.controlMode = null;
        let handLandmarker;
        let steeringInput = 0; 
        let throttleInput = 0.8;
        let lastVideoTime = -1;
        let bgMusic;
        const video = document.getElementById("webcam");

        window.startGame = async function(mode) {
            if (game.sound.context.state === 'suspended') game.sound.context.resume();
            window.controlMode = mode;
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('ui-side').style.display = 'block';
            if (mode === 'camera') await initAI();
            else if (mode === 'gyro') initGyro();
            if (bgMusic) bgMusic.play({ loop: true, volume: 0.4 });
            document.documentElement.requestFullscreen().catch(() => {});
        };

        const config = {
            type: Phaser.AUTO,
            parent: 'game-container',
            width: window.innerWidth,
            height: window.innerHeight,
            physics: { default: 'arcade' },
            scene: { preload, create, update }
        };

        const game = new Phaser.Game(config);
        let player, roadLines, decorGroup, enemies, progressMarker, smoothSteer = 0;

        function preload() {
            this.load.image('playerCar', 'car.png');
            this.load.image('enemy1', 'car1.png');
            this.load.image('enemy2', 'car2.png');
            this.load.image('enemy3', 'car3.png');
            this.load.image('enemy4', 'car4.png');
            this.load.audio('gameMusic', 'bgm.mp3'); 
        }

        function create() {
            const w = this.cameras.main.width;
            const h = this.cameras.main.height;
            bgMusic = this.sound.add('gameMusic');

            // NES Side Panels (UNUTULMADI!)
            this.add.rectangle(65, h/2, 130, h, 0x555555).setDepth(5);
            this.add.rectangle(65, h/2, 8, h * 0.7, 0x000).setDepth(6);
            progressMarker = this.add.rectangle(65, h * 0.8, 18, 10, 0xff0000).setDepth(7);

            // Yol & Çimen
            const roadW = w * 0.55;
            this.add.rectangle(w/2 - roadW/2 - 100, h/2, 200, h, 0x008800);
            this.add.rectangle(w/2 + roadW/2 + 100, h/2, 200, h, 0x008800);
            this.add.rectangle(w/2, h/2, roadW + 15, h, 0xffffff); 
            this.add.rectangle(w/2, h/2, roadW, h, 0x222222); 

            roadLines = this.add.group();
            decorGroup = this.add.group();
            enemies = this.physics.add.group();

            for(let i=0; i<12; i++) {
                roadLines.add(this.add.rectangle(w/2, i * 130, 8, 50, 0x555555));
                decorGroup.add(this.add.circle(w/2 - roadW/2 - 60, i * 200, 25, 0x004400));
                decorGroup.add(this.add.circle(w/2 + roadW/2 + 60, i * 200, 25, 0x004400));
            }

            player = this.physics.add.sprite(w/2, h - 150, 'playerCar').setScale(0.55).setDepth(100);
            
            this.time.addEvent({
                delay: 2200,
                callback: () => {
                    if (!window.controlMode) return;
                    let xPos = Phaser.Math.Between(w/2 - roadW/2 + 50, w/2 + roadW/2 - 50);
                    let randomKey = 'enemy' + Phaser.Math.Between(1, 4);
                    enemies.create(xPos, -100, randomKey).setScale(0.55).setDepth(90);
                },
                loop: true
            });
        }

        function update() {
            if (!window.controlMode) return;

            // Merkeze dönmeyen pürüzsüz direksiyon
            steeringInput = Phaser.Math.Clamp(steeringInput, -1, 1);
            smoothSteer = Phaser.Math.Linear(smoothSteer, steeringInput, 0.08);
            
            // Optimize edilmiş hız (Maks ~130 km/h)
            let speed = Phaser.Math.Linear(16, 4, throttleInput);

            roadLines.getChildren().forEach(line => {
                line.y += speed;
                if (line.y > this.cameras.main.height) line.y = -100;
            });

            decorGroup.getChildren().forEach(d => {
                d.y += speed;
                if (d.y > this.cameras.main.height) d.y = -100;
            });

            enemies.getChildren().forEach(enemy => {
                enemy.y += speed * 0.65; 
                if (enemy.y > this.cameras.main.height + 150) enemy.destroy();
            });

            // Sınırlar
            let roadLimit = this.cameras.main.width * 0.24;
            player.x = (this.cameras.main.width/2) + (smoothSteer * (this.cameras.main.width * 0.28));
            player.x = Phaser.Math.Clamp(player.x, this.cameras.main.width/2 - roadLimit, this.cameras.main.width/2 + roadLimit);
            player.angle = smoothSteer * 12;

            // NES İlerleme Çubuğu Güncelleme
            progressMarker.y = (this.cameras.main.height * 0.8) - ((speed * 20) % (this.cameras.main.height * 0.6));

            document.getElementById("kmh").innerText = Math.floor(speed * 8);
            document.getElementById("score").innerText = String(Math.floor(speed * 120)).padStart(6, '0');
        }

        async function initAI() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                runningMode: "VIDEO", numHands: 2
            });
            navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" } }).then(s => {
                video.srcObject = s; video.addEventListener("loadeddata", predictCamera);
            });
        }

        function initGyro() {
            window.addEventListener('deviceorientation', (e) => {
                if(window.controlMode !== 'gyro') return;
                let tilt = window.innerHeight > window.innerWidth ? e.gamma : e.beta;
                steeringInput = Phaser.Math.Clamp(tilt / 25, -1, 1);
            });
        }

        async function predictCamera() {
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                const res = handLandmarker.detectForVideo(video, performance.now());
                if (res.landmarks && res.landmarks.length === 2) {
                    let h1 = res.landmarks[0][0], h2 = res.landmarks[1][0];
                    let deg = Math.atan2(h2.y - h1.y, h2.x - h1.x) * (180 / Math.PI);
                    if (deg > 90) deg -= 180; if (deg < -90) deg += 180;
                    steeringInput = -deg / 15; 
                    throttleInput = (h1.y + h2.y) / 2;
                }
            }
            requestAnimationFrame(predictCamera);
        }
    </script>
</body>
</html>