<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Road Fighter - Final AI Steering</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/vision_bundle.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        #webcam { display: none; }
        
        /* GÖRSEL DİREKSİYON */
        #steering-container {
            position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%);
            width: 120px; height: 120px; border: 8px solid #ff0000; border-radius: 50%;
            z-index: 300; display: none; transition: background 0.3s;
            box-shadow: 0 0 20px rgba(255,0,0,0.5);
        }
        #steering-container::after {
            content: ''; position: absolute; top: 50%; left: 0; width: 100%; height: 8px;
            background: currentColor; transform: translateY(-50%);
        }
        #steering-container.active { border-color: #00ff00; color: #00ff00; box-shadow: 0 0 30px #00ff00; }

        #start-screen {
            position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
            background: #000; z-index: 500; display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: #fff;
        }
        .menu-btn {
            width: 320px; padding: 18px; margin: 12px; border: 4px double #444;
            background: #111; color: #888; font-size: 18px; font-weight: bold;
            transition: 0.2s; outline: none; cursor: pointer; text-align: center;
        }
        .menu-btn.active, .menu-btn:hover { border-color: #ffff00; color: #fff; box-shadow: 0 0 20px #f00; }
        #ui-side { position: absolute; top: 20px; right: 5%; color: #fff; z-index: 200; display: none; text-align: right; }
        .retro-label { color: #ffff00; font-size: 14px; }
        .retro-value { font-size: 28px; font-weight: bold; margin-bottom: 5px; }
        #fuel-bar-bg { width: 150px; height: 15px; border: 2px solid #fff; background: #333; margin-top: 5px; float: right; }
        #fuel-bar-fill { width: 100%; height: 100%; background: #f00; transition: width 0.2s; }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1 style="color:#ffff00; text-shadow: 3px 3px #f00; font-size: 36px; margin-bottom:30px;">ROAD FIGHTER</h1>
        <div class="menu-btn active" onclick="startGame('camera')">1. AI CAMERA</div>
        <div class="menu-btn" onclick="startGame('gyro')">2. PHONE TILT</div>
        <div class="menu-btn" onclick="startGame('keyboard')">3. TOUCH / REMOTE / KEYS</div>
        <p style="color: #666; font-size: 14px; margin-top: 20px;">AI: ELLERİNİ SAĞA/SOLA YATIR</p>
    </div>

    <div id="steering-container"></div>

    <div id="ui-side">
        <div class="retro-label">1P SCORE</div>
        <div class="retro-value" id="score">000000</div>
        <div class="retro-label">FUEL</div>
        <div id="fuel-bar-bg"><div id="fuel-bar-fill"></div></div>
        <div style="clear:both; margin-bottom: 10px;"></div>
        <div class="retro-label">SPEED</div>
        <div class="retro-value" style="color:#00ff00;"><span id="kmh">0</span> km/h</div>
    </div>

    <video id="webcam" autoplay playsinline></video>
    <div id="game-container"></div>

    <script type="module">
        import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

        window.controlMode = null;
        let steeringInput = 0, throttleInput = 0.8, smoothSteer = 0;
        let fuel = 100, score = 0, distanceMoved = 0, currentSpeed = 0;
        const totalCourseLength = 150000;
        let isGameOver = false, isInvincible = false, isTurbo = false;
        let bgMusic, handLandmarker;

        let currentIdx = 0;
        const menuBtns = document.querySelectorAll('.menu-btn');
        window.addEventListener('keydown', (e) => {
            if (window.controlMode === null) {
                if (e.key === 'ArrowDown') { currentIdx = (currentIdx + 1) % 3; updateMenu(); }
                if (e.key === 'ArrowUp') { currentIdx = (currentIdx + 2) % 3; updateMenu(); }
                if (e.key === 'Enter') startGame(['camera','gyro','keyboard'][currentIdx]);
            }
        });
        function updateMenu() { menuBtns.forEach((btn, i) => btn.classList.toggle('active', i === currentIdx)); }

        window.startGame = async function(mode) {
            window.focus();
            if (game.sound.context.state === 'suspended') game.sound.context.resume();
            window.controlMode = mode;
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('ui-side').style.display = 'block';
            if (mode === 'camera') {
                document.getElementById('steering-container').style.display = 'block';
                await initAI();
            }
            if (bgMusic) bgMusic.play({ loop: true, volume: 0.4 });
        };

        const config = {
            type: Phaser.AUTO,
            parent: 'game-container',
            width: window.innerWidth, height: window.innerHeight,
            physics: { default: 'arcade' },
            scene: { preload, create, update }
        };

        const game = new Phaser.Game(config);
        let player, roadLines, decorGroup, enemies, fuels, progressMarker;

        function preload() {
            this.load.image('playerCar', 'car.png');
            this.load.image('enemy1', 'car1.png');
            this.load.image('enemy2', 'car2.png');
            this.load.image('special', 'car3.png'); 
            this.load.audio('gameMusic', 'bgm.mp3'); 
        }

        function create() {
            const w = this.cameras.main.width, h = this.cameras.main.height;
            bgMusic = this.sound.add('gameMusic');

            this.add.rectangle(30, h/2, 40, h, 0x555555).setDepth(5);
            this.add.rectangle(30, h/2, 4, h * 0.8, 0x000).setDepth(6);
            progressMarker = this.add.rectangle(30, h * 0.85, 12, 8, 0xff0000).setDepth(7);

            this.add.rectangle(w/2, h/2, w * 0.5, h, 0x333333); 
            roadLines = this.add.group();
            decorGroup = this.add.group();
            enemies = this.physics.add.group();
            fuels = this.physics.add.group();

            for(let i=0; i<12; i++) {
                roadLines.add(this.add.rectangle(w/2, i * 130, 8, 50, 0xffffff));
                decorGroup.add(this.add.circle(w/2 - (w*0.25) - 50, i * 220, 20, 0x004400));
                decorGroup.add(this.add.circle(w/2 + (w*0.25) + 50, i * 220, 20, 0x004400));
            }

            player = this.physics.add.sprite(w/2, h - 140, 'playerCar').setScale(0.5).setDepth(100);
            
            // --- DOKUNMATİK / ELLE YÖNETME ---
            this.input.on('pointermove', (p) => {
                if (window.controlMode === 'keyboard' && p.isDown) {
                    steeringInput = (p.x - (window.innerWidth/2)) / (window.innerWidth/5);
                    throttleInput = 0.35;
                }
            });
            this.input.on('pointerup', () => { if(window.controlMode === 'keyboard') { throttleInput = 0.8; steeringInput = 0; } });

            this.physics.add.overlap(player, enemies, () => {
                if (isInvincible) return;
                fuel -= 15; isInvincible = true; player.setAlpha(0.5); currentSpeed *= 0.3;
                this.time.delayedCall(2000, () => { isInvincible = false; player.setAlpha(1); });
            });

            this.physics.add.overlap(player, fuels, (p, f) => {
                fuel = Math.min(fuel + 25, 100); f.destroy(); score += 1000;
                isTurbo = true; player.setTint(0x00ffff);
                this.time.delayedCall(3000, () => { isTurbo = false; player.clearTint(); });
            });

            this.time.addEvent({
                delay: 2000,
                callback: () => {
                    if (!window.controlMode || isGameOver) return;
                    let xPos = Phaser.Math.Between(w/2 - (w*0.2), w/2 + (w*0.2));
                    if (Math.random() < 0.22) fuels.create(xPos, -100, 'special').setTint(0x00ffff).setScale(0.5);
                    else enemies.create(xPos, -100, 'enemy'+Phaser.Math.Between(1,2)).setScale(0.5);
                }, loop: true
            });
        }

        function update() {
            if (!window.controlMode || isGameOver) return;

            currentSpeed = Phaser.Math.Linear(currentSpeed, fuel <= 0 ? 0 : Phaser.Math.Linear(isTurbo ? 26 : 18, 2, throttleInput), 0.035);
            if (currentSpeed > 2) fuel -= 0.024;

            steeringInput = Phaser.Math.Clamp(steeringInput, -1.2, 1.2);
            smoothSteer = Phaser.Math.Linear(smoothSteer, steeringInput, 0.1);
            
            roadLines.getChildren().forEach(l => { l.y += currentSpeed; if (l.y > this.cameras.main.height) l.y = -100; });
            decorGroup.getChildren().forEach(d => { d.y += currentSpeed; if (d.y > this.cameras.main.height) d.y = -100; });
            [enemies, fuels].forEach(g => g.getChildren().forEach(e => { e.y += currentSpeed * 0.7; if (e.y > this.cameras.main.height + 100) e.destroy(); }));

            player.x = (this.cameras.main.width/2) + (smoothSteer * (this.cameras.main.width * 0.28));
            player.angle = smoothSteer * 12;

            if (currentSpeed > 1) { distanceMoved += currentSpeed; score += Math.floor(currentSpeed / 4); }
            let progress = distanceMoved / totalCourseLength;
            progressMarker.y = (this.cameras.main.height * 0.85) - (progress * (this.cameras.main.height * 0.75));

            document.getElementById("kmh").innerText = Math.floor(currentSpeed * 11);
            document.getElementById("score").innerText = String(score).padStart(6, '0');
            document.getElementById("fuel-bar-fill").style.width = fuel + "%";

            if (fuel <= 0 && currentSpeed < 0.3) { isGameOver = true; alert("YAKIT BİTTİ!"); location.reload(); }
            if (distanceMoved >= totalCourseLength) { isGameOver = true; alert("TEBRİKLER!"); location.reload(); }
        }

        async function initAI() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                runningMode: "VIDEO", numHands: 2
            });
            navigator.mediaDevices.getUserMedia({ video: true }).then(s => {
                const vid = document.getElementById("webcam"); vid.srcObject = s;
                vid.addEventListener("loadeddata", predictCamera);
            });
        }

        async function predictCamera() {
            const vid = document.getElementById("webcam");
            const steerImg = document.getElementById("steering-container");
            const res = handLandmarker.detectForVideo(vid, performance.now());
            
            if (res.landmarks && res.landmarks.length === 2) {
                steerImg.classList.add('active');
                let h1 = res.landmarks[0][0], h2 = res.landmarks[1][0];
                
                // --- KESİN DİREKSİYYON FIX ---
                // h2 (ikinci el) - h1 (birinci el) farkını alarak eğimi buluyoruz.
                // Ayna etkisini kırmak için değeri -1 ile çarptım.
                let deg = Math.atan2(h2.y - h1.y, h2.x - h1.x) * (180 / Math.PI);
                if (deg > 90) deg -= 180; if (deg < -90) deg += 180;
                
                steeringInput = -(deg / 15); // Negatif yaparak sağa yatınca sağa gitmesini sağladım
                throttleInput = (h1.y + h2.y) / 2;
                
                steerImg.style.transform = `translateX(-50%) rotate(${deg}deg)`;
            } else {
                steerImg.classList.remove('active');
                steeringInput = 0;
            }
            requestAnimationFrame(predictCamera);
        }
    </script>
</body>
</html>
